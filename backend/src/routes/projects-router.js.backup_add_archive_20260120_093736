// projects-router.js - API роутеры для работы с проектами
import express from 'express';
import combinationsRouter from './combinations-router.js';
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import projectService from '../services/project-service.js';
import assetService, { getAssetById } from '../services/asset-service.js';
import masterVideoService from '../services/master-video-service.js';
import db from '../db/database.js';

const router = express.Router();
router.use(combinationsRouter);

// Multer для загрузки файлов
const upload = multer({ 
  dest: '/tmp/uploads/',
  limits: { fileSize: 500 * 1024 * 1024 } // 500MB
});

// ===== ПРОЕКТЫ =====

// GET /api/projects - Получить все проекты
router.get('/', async (req, res) => {
  try {
    const projects = projectService.getAllProjects();
    res.json({ success: true, projects });
  } catch (error) {
    console.error('[API] Error getting projects:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/projects/:project_id - Получить проект
router.get('/:project_id', async (req, res) => {
  try {
    const project = projectService.getProject(req.params.project_id);
    
    if (!project) {
      return res.status(404).json({ success: false, error: 'Project not found' });
    }
    
    res.json({ success: true, project });
  } catch (error) {
    console.error('[API] Error getting project:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/projects - Создать проект
router.post('/', async (req, res) => {
  try {
    const { name, description } = req.body;
    
    if (!name) {
      return res.status(400).json({ success: false, error: 'Name is required' });
    }
    
    const project = await projectService.createProject({ name, description });
    
    res.json({ success: true, project });
  } catch (error) {
    console.error('[API] Error creating project:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PATCH /api/projects/:project_id - Обновить проект
router.patch('/:project_id', async (req, res) => {
  try {
    const project = projectService.updateProject(req.params.project_id, req.body);
    
    if (!project) {
      return res.status(404).json({ success: false, error: 'Project not found' });
    }
    
    res.json({ success: true, project });
  } catch (error) {
    console.error('[API] Error updating project:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/projects/:project_id - Удалить проект
router.delete('/:project_id', async (req, res) => {
  try {
    const result = projectService.deleteProject(req.params.project_id);
    res.json(result);
  } catch (error) {
    console.error('[API] Error deleting project:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// ===== МАТЕРИАЛЫ =====

// GET /api/projects/:project_id/assets - Получить материалы проекта
router.get('/:project_id/assets', async (req, res) => {
  try {
    const { asset_type } = req.query;
    const assets = assetService.getProjectAssets(req.params.project_id, asset_type);
    
    res.json({ success: true, assets });
  } catch (error) {
    console.error('[API] Error getting assets:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/projects/:project_id/assets - Добавить материал
router.post('/:project_id/assets', upload.single('file'), async (req, res) => {
  try {
    const { asset_type, metadata } = req.body;
    
    if (!req.file) {
      return res.status(400).json({ success: false, error: 'File is required' });
    }
    
    if (!asset_type) {
      return res.status(400).json({ success: false, error: 'Asset type is required' });
    }
    
    // Читаем файл в Buffer для загрузки в S3
    const file_buffer = fs.readFileSync(req.file.path);
    
    const asset = await assetService.addAsset({
      project_id: req.params.project_id,
      asset_type,
      file_buffer,  // Передаём Buffer вместо file_path
      original_filename: req.file.originalname,
      metadata: metadata ? JSON.parse(metadata) : {}
    });
    
    // Удалить временный файл ПОСЛЕ загрузки в S3
    fs.unlinkSync(req.file.path);
    
    res.json({ success: true, asset });
  } catch (error) {
    console.error('[API] Error adding asset:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/projects/:project_id/assets/:asset_id - Удалить материал
router.delete('/:project_id/assets/:asset_id', async (req, res) => {
  try {
    const result = assetService.deleteAsset(req.params.asset_id);
    res.json(result);
  } catch (error) {
    console.error('[API] Error deleting asset:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/projects/:project_id/assets/:asset_id/video - Стрим видео из file_path
router.get('/:project_id/assets/:asset_id/video', async (req, res) => {
  try {
    const asset = getAssetById(req.params.asset_id);
    
    if (!asset) {
      return res.status(404).json({ success: false, error: 'Asset not found' });
    }
    
    // Если есть cdn_url — редирект
    if (asset.cdn_url) {
      return res.redirect(asset.cdn_url);
    }
    
    // Иначе стримим из file_path
    if (!asset.file_path) {
      return res.status(404).json({ success: false, error: 'Video file not available' });
    }
    
    // Проверяем существование файла
    if (!fs.existsSync(asset.file_path)) {
      return res.status(404).json({ success: false, error: 'Video file not found on disk' });
    }
    
    // Получаем размер файла
    const stat = fs.statSync(asset.file_path);
    const fileSize = stat.size;
    const range = req.headers.range;
    
    // Поддержка Range запросов для видео
    if (range) {
      const parts = range.replace(/bytes=/, '').split('-');
      const start = parseInt(parts[0], 10);
      const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
      const chunksize = (end - start) + 1;
      const file = fs.createReadStream(asset.file_path, { start, end });
      const head = {
        'Content-Range': `bytes ${start}-${end}/${fileSize}`,
        'Accept-Ranges': 'bytes',
        'Content-Length': chunksize,
        'Content-Type': 'video/mp4',
      };
      res.writeHead(206, head);
      file.pipe(res);
    } else {
      const head = {
        'Content-Length': fileSize,
        'Content-Type': 'video/mp4',
      };
      res.writeHead(200, head);
      fs.createReadStream(asset.file_path).pipe(res);
    }
  } catch (error) {
    console.error('[API] Error streaming video:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});


// ===== МАСТЕР-РОЛИКИ =====

// GET /api/projects/:project_id/master-videos - Получить мастер-ролики
router.get('/:project_id/master-videos', async (req, res) => {
  try {
    const masterVideos = masterVideoService.getProjectMasterVideos(req.params.project_id);
    
    res.json({ success: true, master_videos: masterVideos });
  } catch (error) {
    console.error('[API] Error getting master videos:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/projects/:project_id/master-videos/:master_id - Получить мастер-ролик
router.get('/:project_id/master-videos/:master_id', async (req, res) => {
  try {
    const master = masterVideoService.getMasterVideo(req.params.master_id);
    
    if (!master) {
      return res.status(404).json({ success: false, error: 'Master video not found' });
    }
    
    res.json({ success: true, master_video: master });
  } catch (error) {
    console.error('[API] Error getting master video:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/projects/:project_id/master-videos - Создать мастер-ролик
router.post('/:project_id/master-videos', async (req, res) => {
  try {
    const { name, shots_config, metadata } = req.body;
    
    if (!name) {
      return res.status(400).json({ success: false, error: 'Name is required' });
    }
    
    if (!shots_config) {
      return res.status(400).json({ success: false, error: 'Shots config is required' });
    }
    
    const master = await masterVideoService.createMasterVideo({
      project_id: req.params.project_id,
      name,
      shots_config,
      metadata: metadata || {}
    });
    
    res.json({ success: true, master_video: master });
  } catch (error) {
    console.error('[API] Error creating master video:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PATCH /api/projects/:project_id/master-videos/:master_id/status - Обновить статус
router.patch('/:project_id/master-videos/:master_id/status', async (req, res) => {
  try {
    const { status } = req.body;
    
    if (!status) {
      return res.status(400).json({ success: false, error: 'Status is required' });
    }
    
    const master = masterVideoService.updateMasterVideoStatus(req.params.master_id, status);
    
    res.json({ success: true, master_video: master });
  } catch (error) {
    console.error('[API] Error updating status:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/projects/:project_id/master-videos/:master_id/markers - Сохранить маркеры
router.post('/:project_id/master-videos/:master_id/markers', async (req, res) => {
  try {
    const { markers } = req.body;
    
    if (!Array.isArray(markers)) {
      return res.status(400).json({ success: false, error: 'Markers must be an array' });
    }
    
    const master = masterVideoService.saveSyncMarkers(req.params.master_id, markers);
    
    res.json({ success: true, master_video: master });
  } catch (error) {
    console.error('[API] Error saving markers:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/projects/:project_id/master-videos/:master_id/approve - Одобрить мастер-ролик
router.post('/:project_id/master-videos/:master_id/approve', async (req, res) => {
  try {
    const master = masterVideoService.approveMasterVideo(req.params.master_id);
    
    res.json({ success: true, master_video: master });
  } catch (error) {
    console.error('[API] Error approving master video:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/projects/:project_id/master-videos/:master_id - Удалить мастер-ролик
router.delete('/:project_id/master-videos/:master_id', async (req, res) => {
  try {
    const result = masterVideoService.deleteMasterVideo(req.params.master_id);
    res.json(result);
  } catch (error) {
    console.error('[API] Error deleting master video:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});






// ========== SCALE JOBS API ==========

// POST /api/projects/:id/master-videos/:master_id/scale - Создать задачу нарезки
router.post('/:id/master-videos/:master_id/scale', async (req, res) => {
  try {
    const { id: projectId, master_id: masterId } = req.params;
    const { count = 10, formats = ['16:9'] } = req.body;
    
    // Валидация
    if (count < 1 || count > 100) {
      return res.status(400).json({ 
        success: false, 
        error: 'count must be between 1 and 100' 
      });
    }
    
    const validFormats = ['16:9', '9:16', '1:1', '4:5'];
    const invalidFormats = formats.filter(f => !validFormats.includes(f));
    if (invalidFormats.length > 0) {
      return res.status(400).json({ 
        success: false, 
        error: `Invalid formats: ${invalidFormats.join(', ')}. Valid: ${validFormats.join(', ')}` 
      });
    }
    
    // Проверяем, что master video существует
    const master = db.prepare(`
      SELECT * FROM master_videos 
      WHERE master_id = ? AND project_id = ?
    `).get(masterId, projectId);
    
    if (!master) {
      return res.status(404).json({ 
        success: false, 
        error: 'Master video not found' 
      });
    }
    
    if (master.status !== 'completed' || !master.video_path) {
      return res.status(400).json({ 
        success: false, 
        error: 'Master video is not ready yet' 
      });
    }
    
    // Создаём задачу
    const jobId = `job_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
    const now = new Date().toISOString();
    
    db.prepare(`
      INSERT INTO scale_jobs (
        job_id, project_id, master_video_id, 
        count, formats, status, 
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      jobId, projectId, masterId, 
      count, JSON.stringify(formats), 'queued',
      now, now
    );
    
    res.json({
      success: true,
      message: `Scale job created: ${count} versions x ${formats.length} formats = ${count * formats.length} total videos`,
      job: {
        job_id: jobId,
        project_id: projectId,
        master_video_id: masterId,
        count,
        formats,
        status: 'queued',
        created_at: now
      }
    });
    
  } catch (error) {
    console.error('[API] Error creating scale job:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/projects/:id/scale-jobs - Получить все задачи нарезки для проекта
router.get('/:id/scale-jobs', async (req, res) => {
  try {
    const projectId = req.params.id;
    
    const jobs = db.prepare(`
      SELECT * FROM scale_jobs 
      WHERE project_id = ? 
      ORDER BY created_at DESC
    `).all(projectId);
    
    // Парсим formats из JSON
    const jobsWithFormats = jobs.map(job => ({
      ...job,
      formats: JSON.parse(job.formats)
    }));
    
    res.json({
      success: true,
      count: jobs.length,
      jobs: jobsWithFormats
    });
    
  } catch (error) {
    console.error('[API] Error fetching scale jobs:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/projects/:id/scale-jobs/:job_id - Получить конкретную задачу
router.get('/:id/scale-jobs/:job_id', async (req, res) => {
  try {
    const { id: projectId, job_id: jobId } = req.params;
    
    const job = db.prepare(`
      SELECT * FROM scale_jobs 
      WHERE job_id = ? AND project_id = ?
    `).get(jobId, projectId);
    
    if (!job) {
      return res.status(404).json({ 
        success: false, 
        error: 'Scale job not found' 
      });
    }
    
    // Получаем список сгенерированных видео
    const videos = db.prepare(`
      SELECT * FROM scaled_videos 
      WHERE job_id = ? 
      ORDER BY format, sequence
    `).all(jobId);
    
    res.json({
      success: true,
      job: {
        ...job,
        formats: JSON.parse(job.formats)
      },
      videos: {
        total: videos.length,
        completed: videos.filter(v => v.status === 'completed').length,
        failed: videos.filter(v => v.status === 'failed').length,
        processing: videos.filter(v => v.status === 'processing').length,
        items: videos
      }
    });
    
  } catch (error) {
    console.error('[API] Error fetching scale job:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/projects/:id/scale-jobs/:job_id/videos - Получить все видео задачи
router.get('/:id/scale-jobs/:job_id/videos', async (req, res) => {
  try {
    const { id: projectId, job_id: jobId } = req.params;
    const { format, status } = req.query;
    
    // Проверяем, что job существует
    const job = db.prepare(`
      SELECT * FROM scale_jobs 
      WHERE job_id = ? AND project_id = ?
    `).get(jobId, projectId);
    
    if (!job) {
      return res.status(404).json({ 
        success: false, 
        error: 'Scale job not found' 
      });
    }
    
    // Строим запрос с фильтрами
    let query = 'SELECT * FROM scaled_videos WHERE job_id = ?';
    const params = [jobId];
    
    if (format) {
      query += ' AND format = ?';
      params.push(format);
    }
    
    if (status) {
      query += ' AND status = ?';
      params.push(status);
    }
    
    query += ' ORDER BY format, sequence';
    
    const videos = db.prepare(query).all(...params);
    
    res.json({
      success: true,
      count: videos.length,
      videos
    });
    
  } catch (error) {
    console.error('[API] Error fetching scaled videos:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/projects/:id/scaled-videos/:scaled_id/video - Просмотр scaled video
router.get('/:id/scaled-videos/:scaled_id/video', async (req, res) => {
  try {
    const { scaled_id: scaledId } = req.params;
    
    const video = db.prepare('SELECT * FROM scaled_videos WHERE scaled_id = ?').get(scaledId);
    
    if (!video || !video.video_path) {
      return res.status(404).json({ success: false, error: 'Video not found' });
    }
    
    const videoPath = video.video_path;
    if (!fs.existsSync(videoPath)) {
      return res.status(404).json({ success: false, error: 'Video file not found on disk' });
    }
    
    const stat = fs.statSync(videoPath);
    const fileSize = stat.size;
    const range = req.headers.range;
    
    if (range) {
      const parts = range.replace(/bytes=/, "").split("-");
      const start = parseInt(parts[0], 10);
      const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
      const chunksize = (end - start) + 1;
      const file = fs.createReadStream(videoPath, { start, end });
      
      res.writeHead(206, {
        'Content-Range': `bytes ${start}-${end}/${fileSize}`,
        'Accept-Ranges': 'bytes',
        'Content-Length': chunksize,
        'Content-Type': 'video/mp4',
      });
      file.pipe(res);
    } else {
      res.writeHead(200, {
        'Content-Length': fileSize,
        'Content-Type': 'video/mp4',
      });
      fs.createReadStream(videoPath).pipe(res);
    }
    
  } catch (error) {
    console.error('[API] Error streaming scaled video:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/projects/:id/scaled-videos/:scaled_id/download - Скачивание scaled video
router.get('/:id/scaled-videos/:scaled_id/download', async (req, res) => {
  try {
    const { scaled_id: scaledId } = req.params;
    
    const video = db.prepare('SELECT * FROM scaled_videos WHERE scaled_id = ?').get(scaledId);
    
    if (!video || !video.video_path) {
      return res.status(404).json({ success: false, error: 'Video not found' });
    }
    
    const videoPath = video.video_path;
    if (!fs.existsSync(videoPath)) {
      return res.status(404).json({ success: false, error: 'Video file not found on disk' });
    }
    
    const filename = `scaled_${video.format.replace(':', 'x')}_seq${video.sequence}.mp4`;
    res.download(videoPath, filename);
    
  } catch (error) {
    console.error('[API] Error downloading scaled video:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});


// ========== MASTER VIDEO STREAMING & DOWNLOAD ==========

// GET /api/projects/:project_id/master-videos/:master_id/video - Просмотр
router.get('/:project_id/master-videos/:master_id/video', async (req, res) => {
  try {
    const { project_id, master_id } = req.params;
    
    const master = db.prepare(`
      SELECT video_path, status, name 
      FROM master_videos 
      WHERE master_id = ? AND project_id = ?
    `).get(master_id, project_id);
    
    if (!master) {
      return res.status(404).json({ error: 'Master video not found' });
    }
    
    if (master.status !== 'completed' || !master.video_path) {
      return res.status(400).json({ error: 'Video not ready', status: master.status });
    }
    
    const videoPath = master.video_path;
    
    if (!fs.existsSync(videoPath)) {
      return res.status(404).json({ error: 'Video file not found on disk' });
    }
    
    const stat = fs.statSync(videoPath);
    const fileSize = stat.size;
    const range = req.headers.range;
    
    if (range) {
      const parts = range.replace(/bytes=/, "").split("-");
      const start = parseInt(parts[0], 10);
      const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
      const chunksize = (end - start) + 1;
      const file = fs.createReadStream(videoPath, { start, end });
      const head = {
        'Content-Range': `bytes ${start}-${end}/${fileSize}`,
        'Accept-Ranges': 'bytes',
        'Content-Length': chunksize,
        'Content-Type': 'video/mp4',
      };
      res.writeHead(206, head);
      file.pipe(res);
    } else {
      const head = {
        'Content-Length': fileSize,
        'Content-Type': 'video/mp4',
      };
      res.writeHead(200, head);
      fs.createReadStream(videoPath).pipe(res);
    }
  } catch (error) {
    console.error('Error streaming master video:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// GET /api/projects/:project_id/master-videos/:master_id/download - Скачивание
router.get('/:project_id/master-videos/:master_id/download', async (req, res) => {
  try {
    const { project_id, master_id } = req.params;
    
    const master = db.prepare(`
      SELECT video_path, status, name 
      FROM master_videos 
      WHERE master_id = ? AND project_id = ?
    `).get(master_id, project_id);
    
    if (!master) {
      return res.status(404).json({ error: 'Master video not found' });
    }
    
    if (master.status !== 'completed' || !master.video_path) {
      return res.status(400).json({ error: 'Video not ready', status: master.status });
    }
    
    const videoPath = master.video_path;
    
    if (!fs.existsSync(videoPath)) {
      return res.status(404).json({ error: 'Video file not found on disk' });
    }
    
    const filename = `${master.name}_${master_id}.mp4`;
    res.download(videoPath, filename);
    
  } catch (error) {
    console.error('Error downloading master video:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
